#!/usr/bin/env perl
use strict;
use warnings;

# Partly taken from https://www.forbes.com/sites/rogerkay/2011/12/19/generous-tit-for-tat-a-winning-strategy
# And https://medium.com/thinking-is-hard/a-prisoners-dilemma-cheat-sheet-4d85fe289d87

use lib '/Users/gene/sandbox/Game-Theory-TwoPersonMatrix/lib';
use Game::Theory::TwoPersonMatrix;
use Algorithm::Combinatorics qw/ combinations /;
use List::Util::WeightedChoice qw/ choose_weighted /;

use constant COOP   => 1;
use constant DEFECT => 2;

# Set the number of moves
my $max = shift || 200;

my $players = {
    jesus   => [ \&cooperate, \&cooperate ],
    lucifer => [ \&defect, \&defect ],
    random  => [ \&random, \&random ],
    tft     => [ \&cooperate, \&tit_for_tat ],
    atft    => [ \&defect, \&tit_for_tat ], # "Agressive tit-for-tat"
    rtft    => [ \&defect, \&rev_tit_for_tat ],
    tftt    => [ \&cooperate, \&tit_for_two_tats ],
    gtft    => [ \&cooperate, \&generous_tit_for_tat ],
    grim    => [ \&cooperate, \&grim ],
    fbf     => [ \&cooperate, \&firm_but_fair ],
};

my $population = [
    ('jesus')   x 2,
    ('lucifer') x 2,
    ('random')  x 2,
    ('tft')     x 2,
    ('rtft')    x 2,
    ('atft')    x 2,
    ('tftt')    x 2,
    ('gtft')    x 2,
    ('grim')    x 2,
    ('fbf')     x 2,
];

my %scores;
@scores{ keys %$players } = (0) x keys %$players;

my %wins;
@wins{ keys %$players } = (0) x keys %$players;

# A Prisoner's Dilemma
my $g = Game::Theory::TwoPersonMatrix->new(
    payoff1 => [ [3, 0], [5, 1] ],
    payoff2 => [ [3, 5], [0, 1] ],
);

my $iter = combinations( $population, 2 );

my $i = 0;

while ( my $pair = $iter->next ) {
    $i++;
#    print "$i: @$pair\n";

    my @moves;

    # Set initial strategies
    my %strategy = (
        1 => $players->{ $pair->[0] }[0]->()->{1},
        2 => $players->{ $pair->[1] }[0]->()->{2},
    );

    for my $n ( 1 .. $max ) {
        # Each player makes a move
        my ($play) = $g->play(%strategy);

        # The strategies are encoded in the key
        push @moves, ( keys %$play )[0];

        # Update the score for each player
        my ($p) = values %$play;
        $scores{ $pair->[0] } += $p->[0];
        $scores{ $pair->[1] } += $p->[1];

        if ( $p->[0] > $p->[1] ) {
            $wins{ $pair->[0] }++;
        }
        elsif ( $p->[1] > $p->[0] ) {
            $wins{ $pair->[1] }++;
        }

        # Set next strategies
        %strategy = (
            1 => $players->{ $pair->[0] }[1]->(\@moves)->{1},
            2 => $players->{ $pair->[1] }[1]->(\@moves)->{2},
        );
    }
}

print "Wins:\n";
for my $player ( sort { $wins{$b} <=> $wins{$a} } keys %wins ) {
    print "\t$player = $wins{$player}\n";
}

print "Scores:\n";
for my $player ( sort { $scores{$b} <=> $scores{$a} } keys %scores ) {
    print "\t$player = $scores{$player}\n";
}

sub random {
    return {
        1 => { 1 => 0.5, 2 => 0.5 },
        2 => { 1 => 0.5, 2 => 0.5 }
    };
}

sub cooperate {
    # Always cooperate
    return {
        1 => { 1 => 1, 2 => 0 },
        2 => { 1 => 1, 2 => 0 },
    };
}

sub defect {
    # Always defect
    return {
        1 => { 1 => 0, 2 => 1 },
        2 => { 1 => 0, 2 => 1 },
    };
}

sub grim { # https://en.wikipedia.org/wiki/Grim_trigger
    my $moves = shift;

    #    Player1, Player2
    my ( $strat1, $strat2 ) = split /,/, $moves->[-1];

    # Cooperate until defected against, then defect forever
    return {
        1 => {                                                      # Player1
            1 => $strat1 == COOP && $strat2 == COOP ? 1 : 0,        # Cooperate
            2 => $strat1 == DEFECT || $strat2 == DEFECT ? 1 : 0,    # Defect
        },
        2 => {                                                      # Player2
            1 => $strat1 == COOP && $strat2 == COOP ? 1 : 0,        # Cooperate
            2 => $strat1 == DEFECT || $strat2 == DEFECT ? 1 : 0,    # Defect
        },
    }
}

sub tit_for_tat { # https://en.wikipedia.org/wiki/Tit_for_tat
    my $moves = shift;

    my ( $strat1, $strat2 ) = split /,/, $moves->[-1];

    # Do whatever the opponent did the last move
    return {
        1 => {
            1 => $strat2 == COOP ? 1 : 0,
            2 => $strat2 == DEFECT ? 1 : 0,
        },
        2 => {
            1 => $strat1 == COOP ? 1 : 0,
            2 => $strat1 == DEFECT ? 1 : 0,
        },
    }
}

sub generous_tit_for_tat {
    my $moves = shift;

    my ( $strat1, $strat2 ) = split /,/, $moves->[-1];

    my $defect1 = $strat2 == DEFECT && choose_weighted( [ 1, 0 ], [ 9, 1 ] );
    my $defect2 = $strat1 == DEFECT && choose_weighted( [ 1, 0 ], [ 9, 1 ] );

    # Tit-for-tat except 10% cooperate when defected against
    return {
        1 => {
            1 => !$defect1 ? 1 : 0,
            2 => $defect1 ? 1 : 0,
        },
        2 => {
            1 => !$defect2 ? 1 : 0,
            2 => $defect2 ? 1 : 0,
        },
    }
}


sub rev_tit_for_tat {
    my $moves = shift;

    my ( $strat1, $strat2 ) = split /,/, $moves->[-1];

    # Do the opposite of whatever the opponent did the last move
    return {
        1 => {
            1 => $strat2 == DEFECT ? 1 : 0,
            2 => $strat2 == COOP ? 1 : 0,
        },
        2 => {
            1 => $strat1 == DEFECT ? 1 : 0,
            2 => $strat1 == COOP ? 1 : 0,
        },
    }
}

sub tit_for_two_tats { # https://en.wikipedia.org/wiki/Tit_for_tat#Tit_for_two_tats
    my $moves = shift;

    return cooperate() if @$moves == 1;

    my ( $strat11, $strat12 ) = split /,/, $moves->[-1];
    my ( $strat21, $strat22 ) = split /,/, $moves->[-2];

    # Defect if the opponent has defected twice in a row
    return {
        1 => {
            1 => !( $strat12 == DEFECT && $strat22 == DEFECT ) ? 1 : 0,
            2 => $strat12 == DEFECT && $strat22 == DEFECT ? 1 : 0,
        },
        2 => {
            1 => !( $strat11 == DEFECT && $strat21 == DEFECT ) ? 1 : 0,
            2 => $strat11 == DEFECT && $strat21 == DEFECT ? 1 : 0,
        },
    }
}

sub firm_but_fair {
    my $moves = shift;

    my ( $strat1, $strat2 ) = split /,/, $moves->[-1];

    # Cooperate except after receiving a sucker's payoff
    return {
        1 => {
            1 => !( $strat1 == COOP && $strat2 == DEFECT ) ? 1 : 0,
            2 => $strat1 == COOP && $strat2 == DEFECT ? 1 : 0,
        },
        2 => {
            1 => !( $strat1 == DEFECT && $strat2 == COOP ) ? 1 : 0,
            2 => $strat1 == DEFECT && $strat2 == COOP ? 1 : 0,
        },
    }
}
